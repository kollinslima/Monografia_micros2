\chapter{Fundamentação Teórica}
\label{EmbasamentoTeorico}

\section{Segmentação}

\par Ao se capturar uma imagem para processamento, é muitas vezes conveniente separar regiões de interesse, eliminando elementos alheios. Para este projeto, estamos interessados em obter uma imagem das mãos com o maior nível de detalhe possível.

\par Na tentativa de isolar as mãos em uma imagem foram adotadas 3 técnicas:

\begin{itemize}
\item Detecção de pele
\item Detecção de bordas
\item Detecção de face
\end{itemize}

\subsection{Detecção de Pele}

\par Uma técnica utilizada para detecção de pele é a baseada em cores, ou seja, é considerada pele todos os pixels que estão dentro de uma faixa de cores. Matematicamente, seja a imagem F(x,y) e dois limitantes de cor $\tau 1$ e $\tau 2$, a detecção de pele é feita conforme a equação~\ref{eq:deteccao_pele}.

\begin{equation}
\label{eq:deteccao_pele}
F'(x,y) = \begin{cases} F(x,y), & \mbox{se $\tau 1$ > F(x,y) > $\tau 2$}  \\ 0, & \mbox{caso contrário}\end{cases}
\end{equation}

\par Nos trabalhos consultados, não houve unanimidade quanto à melhor opção de espaço de cores para detecção de pele. Em~\cite{Barros}, é utilizado o espaço de cores YCbCr, o mesmo utilizado por~\cite{Yeo}. Em~\cite{Wen} é utilizado o espaço de cores YUV enquanto~\cite{Chen} faz o reconhecimento de pele no espaço RGB. 
\par Experimentalmente, o melhor resultado foi obtido com o uso do espaço de cor HSV, como feito por~\cite{Rosebrock}, que também aponta as limitações do uso da técnica baseada em cores devido a grande variação de tonalidade de peles.

\subsection{Detecção de Borda} 

\par A detecção de borda realça os limites das regiões, baseando-se na variação de luminosidade~\cite{Pavan}. Este processo se mostra necessário pois realiza a binarização da imagem, evidenciando o elemento de interesse (mãos) e diminuindo a quantidade de características presentes na imagem, o que facilita a classificação posteriormente~\cite{Pavan}.

\par Existe diversos algoritmos que fazem a detecção de borda, tais como operador Roberts, Sobel, Prewitt, etc. Segundo~\cite{Grassi}, as etapas básicas para fazer a detecção de borda são:
\begin{enumerate}
	\item Suavização dos ruídos: nesta etapa, busca-se eliminar a maior quantidade de ruído possível, tomando o cuidado para não destruir as bordas.
	\item Ressaltar Bordas: aplica-se um filtro que realça posição das bordas.
	\item Localizar Bordas: decidir, entre as regiões destacadas, onde existe uma borda efetivamente (eliminação de falsos-positivos).
\end{enumerate}

%\par Por facilidade, foram utilizadas funções prontas da biblioteca \textit{OpenCV} para realizar a detecção de bordas.

\subsection{Detecção de Face}

\par A detecção de face é uma técnica que visa identificar a existência ou não de uma face humana na imagem. Difere do reconhecimento de face, já que não se deseja identificar a pessoa, mas apenas identificar que existe uma pessoa (face).
\par Uma vez que se deseja isolar as mãos, é preciso fazer a identificação e a remoção da face, já que a detecção de pele destaca estas duas regiões~\cite{Yeo}. 
\par Para fazer a detecção de faces foi utilizada a classificação em cascada fornecida pela biblioteca \textit{OpenCV}. Este método recebe um arquivo de características pré-treinado e faz a classificação da imagem com base em diversas características. A face só é detectada se for aprovada ao longo da cascata de classificação, conforme mostra a figura~\ref{fig:cascata_classificacao}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{./Resources/classificador_cascata.png}
	\caption{Processo de classificação em cascata para detecção de face.}
	\label{fig:cascata_classificacao}
\end{figure}

\par Estas 3 etapas mostradas constituem uma fase de pré-processamento da imagem, com o intuito de identificar e isolar as mãos do ambiente. 

\section{\textit{Hash}}

\par Uma função \textit{hash} é uma função unidirecional que mapeia dados de entrada em uma faixa limitada de valores. No presente trabalho é utilizada a função \textit{hash} para mapear uma imagem em um valor numérico de 256-bits.

\par Para fazer a transformação, é utilizado um algoritmo de \textit{Average Hash} seu funcionamento é descrito a seguir~\cite{Krawetz}, para a criação de um \textit{hash} de 64-bits:

\begin{enumerate}
	\item A imagem de entrada é reduzida à 64 pixels (8x8) de modo a eliminar detalhes e componentes de altas frequências.
	\item Conversão para escala de cinza.
	\item Cálculo do valor médio (nível de cinza médio).
	\item A imagem é binarizada seguindo o critério: se o pixel estiver acima da média ele é setado (recebe 255), do contrário recebe o valor 0.
	\item A leitura da imagem (da esquerda para direita, de cima para baixo) gera um código binário, que representa o \textit{hash} desejado.
\end{enumerate}

\section{Classificação}

\par Para fazer o reconhecimento das imagens é preciso fazer uso de um sistema de classificação. Este sistema faz a identificação da imagem com base em um conjunto de treinamento previamente fornecido.
\par Vários são os métodos para fazer a classificação. Em~\cite{Barros} é utilizado máquina de vetores de suporte ou SVM \textit{(Support Vector Machine}); classificador de Bayes é utilizado em~\cite{Wen} e em~\cite{Chen} utiliza-se Modelo oculto de Markov. Para simplificar o desenvolvimento, no entanto, foi adotado um classificador simples para este projeto, o k-NN.

\subsection{Classificador k-NN}

\par O classificador k-NN (\textit{k-Nearest Neighbors}) verifica a distância do elemento de entrada para cada elemento no conjunto de treinamento e faz a classificação baseado nos k elementos mais próximos. A medida de distância deve ser definida com base nos elementos a serem classificados.
\par O k-NN suporta naturalmente uma aprendizagem incremental e utiliza uma abordagem \textit{lazy}, ou seja, o algoritmo de aprendizagem retém informações de treinamento e apenas constroi um modelo ao receber uma entrada a ser classificada~\cite{Rossi}.
\par Para entender o processo de classificação, considere a tabela~\ref{tab:knn_exemplo} que relaciona uma entrada numérica à uma cor. Suponha que ela represente um conjunto de treinamento.

\begin{table}[H]
	\centering
	\caption{Exemplo de características}
	\label{tab:knn_exemplo}
	\begin{tabular}{|c|c|}
		\hline
		\textbf{Número} & \textbf{Cor} \\ \hline
		10 & Azul \\ \hline
		21 & Vermelho \\ \hline
		12 & Azul \\ \hline
		20 & Vermelho \\ \hline
	\end{tabular}
\end{table}

\par Se uma entrada de valor 17 for aplicada neste classificador, pode-se utilizar como medida de distância o módulo da diferença entre os dados do conjunto de treinamento e a entrada.

\begin{equation*}
d1 = \sqrt{(17 - 10)^2} = 7
\end{equation*}
\begin{equation*}
d2 = \sqrt{(17 - 21)^2} = 4
\end{equation*}
\begin{equation*}
d3 = \sqrt{(17 - 12)^2} = 5
\end{equation*}
\begin{equation*}
d4 = \sqrt{(17 - 20)^2} = 3
\end{equation*}

\par Para k=3 (considerando 3 vizinhos mais próximos), devemos considerar apenas as 3 menores distâncias (d4,d2 e d3). Atribui-se uma pontuação à cada um dos vizinhos, que deve ser maior quanto menor for a distância, conforme mostra a tabela~\ref{tab:ranking_knn}.

\begin{table}[H]
	\centering
	\caption{Ranking dos vizinhos mais próximos}
	\label{tab:ranking_knn}
	\begin{tabular}{|c|c|}
		\hline
		\textbf{Pontuação (1/d)} & \textbf{Cor} \\ \hline
		1/3 & Vermelho \\ \hline
		1/4 & Vermelho \\ \hline
		1/5 & Azul \\ \hline		
	\end{tabular}
\end{table}

\par Por fim, verifica-se qual elemento (cor) possui a maior pontuação. Neste caso, a cor vermelha é a cor mais bem pontuada considerando os 3 vizinhos e portanto o classificador escolhe esta cor como resultado.




