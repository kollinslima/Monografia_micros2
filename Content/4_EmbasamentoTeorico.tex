\chapter{Fundamentação Teórica}
\label{EmbasamentoTeorico}

\section{Segmentação}

\par Ao se capturar uma imagem para processamento, é muitas vezes conveniente separar regiões de interesse, eliminando elementos alheios. Para este projeto, estamos interessados em obter uma imagem das mãos com o maior nível de detalhe possível.

\par Na tentativa de isolar as mãos em uma imagem foram adotadas 3 técnicas:

\begin{itemize}
\item Detecção de pele
\item Detecção de bordas
\item Detecção de face
\end{itemize}

\subsection{Detecção de Pele}

\par Uma técnica utilizada para detecção de pele é a baseada em cores, ou seja, é considerada pele todos os pixels que estão dentro de uma faixa de cores. Matematicamente, seja a imagem F(x,y) e dois limitantes $\tau 1$ e $\tau 2$, a detecção de pele é feita conforme a equação~\ref{eq:deteccao_pele}.

\begin{equation}
\label{eq:deteccao_pele}
F(x,y) = \begin{cases} F(x,y), & \mbox{se $\tau 1$ > F(x,y) > $\tau 2$}  \\ 0, & \mbox{caso contrário}\end{cases}
\end{equation}

\par Nos trabalhos consultados, não houve unanimidade quanto à melhor opção de espaço de cores para detecção de pele. Em~\cite{Barros}, é utilizado o espaço de cores YCbCr, o mesmo utilizado por~\cite{Yeo}. Em~\cite{Wen} é utilizado o espaço de cores YUV enquanto~\cite{Chen} faz o reconhecimento de pele no espaço RGB. 
\par Experimentalmente, o melhor resultado foi obtido com o uso do espaço de cor HSV, como feito por~\cite{Rosebrock}, que também aponta as limitações do uso da técnica baseada em cores devido a grande variação de tonalidade de peles.

\subsection{Detecção de Borda} 

\par A detecção de borda realça os limites das regiões, baseando-se na variação de luminosidade~\cite{Pavan}. Este processo se mostra necessário pois realiza a binarização da imagem, evidenciando o elemento de interesse (mãos) e diminuindo a quantidade de características presentes na imagem, o que facilita a classificação posteriormente~\cite{Pavan}.

%\par Por facilidade, foram utilizadas funções prontas da biblioteca \textit{OpenCV} para realizar a detecção de bordas.

\subsection{Detecção de Face}

\par A detecção de face é uma técnica que visa identificar a existência ou não de uma face humana na imagem. Difere do reconhecimento de face, já que não se deseja identificar a pessoa, mas apenas identificar que existe uma pessoa (face).
\par Uma vez que se deseja isolar as mãos, é preciso fazer a identificação e a remoção da face, já que a detecção de pele destaca estas duas regiões~\cite{Yeo}. 

\par Estas 3 etapas mostradas constituem uma fase de pré-processamento da imagem, com o intuito de identificar e isolar as mãos do ambiente. 

\section{\textit{Hash}}

\par Uma função \textit{hash} é uma função unidirecional que mapeia dados de entrada em uma faixa limitada de valores. No presente trabalho é utilizada a função \textit{hash} para mapear uma imagem em um valor numérico de 256-bits.

\par Para fazer a transformação, é utilizado um algoritmo de \textit{Average Hash} seu funcionamento é descrito a seguir~\cite{Krawetz} para a criação de um \textit{hash} de 64-bits:

\begin{itemize}
	\item A imagem de entrada é reduzida à 64 pixels (8x8) de modo a eliminar detalhes e componentes de altas frequências.
	\item Conversão para escala de cinza.
	\item Cálculo do valor médio (nível de cinza médio).
	\item A imagem é binarizada seguindo o critério: se o pixel estiver acima da média ele é setado (recebe 255), do contrário recebe o valor 0.
	\item A leitura da imagem (da esquerda para direita, de cima para baixo) gera um código binário, que representa o hash desejado.
\end{itemize}

\section{Classificação}

\par Para fazer o reconhecimento das imagens é preciso fazer uso de um sistema de classificação. Este sistema faz a identificação da imagem com base em um conjunto de treinamento previamente fornecido.
\par Vários são os métodos para fazer a classificação. Em~\cite{Barros} é utilizado máquina de vetores de suporte ou SVM \textit{(Support Vector Machine}); classificador de Bayes é utilizado em~\cite{Wen} e em~\cite{Chen} utiliza-se Modelo oculto de Markov. Para simplificar o desenvolvimento, no entanto, foi adotado um classificador simples para este projeto, o k-NN (k-nearest neighbors).

\subsection{Classificador k-NN}

\par O classificador k-NN (\textit{k-Nearest Neighbors}) verifica a distância do elemento de entrada para cada elemento no conjunto de treinamento e faz a classificação baseado nos k elementos mais próximos. A medida de distância deve ser definida com base nos elementos a serem classificados.
\par O k-NN suporta naturalmente uma aprendizagem incremental e utiliza uma abordagem \textit{lazy}, ou seja, o algoritmo de aprendizagem retém informações de treinamento e apenas constroi um modelo ao receber uma entrada a ser classificada~\cite{Rossi}.
%\par Como exemplo, considere a tabela~\ref{tab:knn_exemplo} que relaciona uma entrada numérica à uma cor. Suponha que ela represente um conjunto de treinamento.
%
%\begin{table}[H]
%	\centering
%	\caption{Exemplo de características}
%	\label{tab:knn_exemplo}
%	\begin{tabular}{|c|c|}
%		\hline
%		\textbf{Número} & \textbf{Cor} \\ \hline
%		10 & Azul \\ \hline
%		21 & Vermelho \\ \hline
%		12 & Azul \\ \hline
%		20 & Vermelho \\ \hline
%	\end{tabular}
%\end{table}
%
%\par Se uma entrada de valor 17 for aplicada neste classificador, pode-se utilizar a distância euclidiana para comparar esta entrada com o conjunto de treinamento. A tabela~\ref{tab:ranking_knn} mostra
%
%\begin{equation*}
%d1 = \sqrt{(17 - 10)^2} = 7
%\end{equation*}
%\begin{equation*}
%d2 = \sqrt{(17 - 21)^2} = 4
%\end{equation*}
%\begin{equation*}
%d3 = \sqrt{(17 - 12)^2} = 5
%\end{equation*}
%\begin{equation*}
%d4 = \sqrt{(17 - 20)^2} = 3
%\end{equation*}
%
%\begin{table}[H]
%	\centering
%	\caption{Ranking dos vizinhos mais próximos.}
%	\label{tab:ranking_knn}
%	\begin{tabular}{|c|c|}
%		\hline
%		\textbf{Número} & \textbf{Cor} \\ \hline
%		10 & Azul \\ \hline
%		21 & Vermelho \\ \hline
%		12 & Azul \\ \hline
%		20 & Vermelho \\ \hline
%	\end{tabular}
%\end{table}
%
%\par Para k=3 (considerando 3 vizinhos mais próximos), 

%Os limites utilizados para fazer a detecção foram:
%
%\begin{equation*}
%	103 < H < 180
%\end{equation*}
%\begin{equation*}
%	0 < S < 100
%\end{equation*}
%\begin{equation*}
%	100 < V < 255
%\end{equation*}




